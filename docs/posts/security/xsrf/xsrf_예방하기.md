# XSRF 예방하기

XSRF 공격은 백엔드 단에서 유효한 API 요청인지를 확인하여 대응해야 합니다.

::: tip
XSRF 공격은 origin이 다른 페이지에서 세션정보(쿠키나 토큰)를 기반으로 위조된 요청을 전송하는 방식입니다.

그럼 동일하거나 허용된 origin을 가진 페이지들 사이에서만 세션정보를 주고받도록 제한하면 문제를 해결할 수 있습니다.
:::

## `Set-Cookie`의 SameSite 속성 확인

사이트 인증과정을 거친 뒤에 전송되는 HTTP 응답 헤더의 `Set-Cookie`의 SameSite 속성을 지정하면 특정 사이트로만 쿠키를 전송할 수 있습니다.

### Lax(default)

`<a href>`, `<link href>`, `<form method>` 사용하여 cross-origin 사이트로 쿠키를 전송할 수 있습니다.

### Strict

오직 same-origin을 가진 사이트에서만 쿠키를 전송할 수 있습니다.

### None

어디로든 쿠키를 전송할 수 있는데, 응답 메시지의 `Set-Cookie` 헤더의 Secure 속성이 반드시 포함되어야 합니다.

## 요청 헤더의 Referer 속성 확인

요청 헤더의 `Referer` 속성에는 해당 요청을 전송한 사이트의 URL(fragment는 제외)이 담기는데 서버에서 이 URL을 확인하여 유효한 요청인지 여부를 확인할 수 있습니다.

## CORS 헤더 지정

HTTP response에 담길 `Access-Control-Allow-Origin`에 '\*' 대신 허용할 origin 값을 구체적으로 명시합니다.

## XSRF token 사용

세션마다 생성되는 토큰으로 고유하고 예측이 어렵고 크기가 큰 난수입니다.

### 동작원리

1. 사용자가 로그인(인증)하는 과정에서 서버는 클라이언트로 쿠키와 함께 xsrf 토큰 복사본을 전송하는 동시에 서버 로컬에 원본 토큰을 저장합니다.

2. 클라이언트가 서버로 요청할 때마다 이 토큰을 HTML form의 hidden input으로서 같이 전달하면 서버에서는 클라이언트에서 전송한 토큰의 값과 원본을 비교합니다.

3. 두 값이 일치하면 요청을 처리하고 일치하지 않으면 요청을 폐기합니다.

### 유의사항

토큰은 쿠키처럼 브라우저 로컬에 저장되어서는 안됩니다.

xsrf token이 효과적인 이유는 공격자 입장에서 토큰 값을 확인할 수도, 예측할 수 없어서 유효하게 보이는 위조요청을 생성하기 어렵기 때문입니다.

그래서 보통 토큰은 `<form>` 내부 `<input type=”hidden” />`에 위치하여 사이트 페이지에 rendering되지 않도록 합니다.
